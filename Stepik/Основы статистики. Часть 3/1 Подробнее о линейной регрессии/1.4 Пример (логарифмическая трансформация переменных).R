library(ggplot2)

qplot(x = hp, y = mpg, data = mtcars)
qplot(x = hp^0.5, y = mpg, data = mtcars)
qplot(x = hp^-0.5, y = mpg, data = mtcars)
qplot(x = -hp^-0.5, y = mpg, data = mtcars)

fit1 <- lm(mpg ~ hp, mtcars)
fit2 <- lm(mpg ~ I(-hp^-0.7), mtcars)

summary(fit1)
summary(fit2)


qplot(x = log(hp), y = log(mpg), data = mtcars)
fit3 <- lm(log(mpg) ~ log(hp), mtcars)
summary(fit3)

# построим гистограмму распределения остатков первой модели,
# а также проведем тест на нормальность распределения

hist(fit1$residuals)
shapiro.test(fit1$residuals)  # распределение остатков не нормальное

# посмотрим, что происходит с другими моделями
hist(fit2$residuals)
shapiro.test(fit2$residuals)  # нет оснований отклонять гипотезу о ненормальности распределения

hist(fit3$residuals)
shapiro.test(fit3$residuals)  # p.value еще выше

# дополнительно:

# Трансформация отдельных предикторов
# Начнем с преобразования значений отдельных предикторов. 
# В качестве примера используем рассмотренные ранее данные GermanCredit по кредитоспособности клиентов 
# одного из немецких банков:

library(caret)
library(e1071)
data(GermanCredit)

summary(GermanCredit) 
# для экономии места вывод результа предыдущей команды сокращен

# Для приведения всех переменных к одинаковым единицам измерения служит стандартизация. 
# Данная операция заключается в вычитании из исходного значения среднего значения
# некоторой переменной 

# В результате стандартизации все количественные переменные будут иметь среднее значение, 
# равное 0, и стандартное отклонение, равное 1

# некоторые переменные имеют также явно выраженные асимметричные распределения (например, Amount и Age),
# что может представлять проблему для некоторых статистических методов
hist(GermanCredit$Amount)
hist(GermanCredit$Age)

# Одной из функций, позволяющих оценить оптимальное значение 
# ?? (степени) по данным, является функция BoxCoxTrans()
AmountTrans = BoxCoxTrans(GermanCredit$Amount)
# из приведенного результата видно, что найденное программой оптимальное значение 
# ?? составило -0.1. Однако с учетом определенной поправочной константы ("fudge factor"), 
# учитывающей случайный характер выборки, итоговое значение ?? составило 0
# Для применения преобразования на основе ??=  0
# к значениям Amount необходимо воспользоваться функцией predict()
fit <- head(predict(AmountTrans, GermanCredit$Amount))
hist(predict(AmountTrans, GermanCredit$Amount)) # теперь распределение похоже на нормальное
