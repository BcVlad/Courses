#######################################################################################
#  вместо корреляции построим регрессионную модель: взаимосвязь миль/галлон топлива и лошадинных сил

df <- mtcars
df_numeric <- df[, c(1, 3:7)]

fit <- lm(mpg ~ hp, df)  # влияние независимой переменной на зависимую перменную
fit  # получим интерсепт и коэффициент
summary(fit)  # показывает описательные статистики для остатков
# p-ур. значимости используется для того, чтобы проверить, отличен ли интерсепт от нуля
# данная информация позволяет сделать вывод о том, есть ли значимая взаимосвязь между предикторами, 
# и отличаются ли искомые коэффициенты от нуля

library(ggplot2)

ggplot(df, aes(hp, mpg)) + #  по оси x отображаем независимую переменную, по оси y - зависимую
  geom_point(size = 2) + 
  geom_smooth()  # добавим на график линию сглаживания (при отсутствии доп. параметров сглаживание нелинейно)

ggplot(df, aes(hp, mpg, col = factor(am))) + #  по оси x отображаем независимую переменную, по оси y - зависимую
  geom_point(size = 2) + 
  geom_smooth(method = "lm")+ # добавим на график линию сглаживания (при отсутствии доп. параметров сглаживание нелинейно). Можно задать линейное сглаживание
  facet_grid(.~cyl)  # разобьём еще данные по количеству цилиндров
  
ggplot(df, aes(hp, mpg)) + #  убрали разбивку по цвету
  geom_point(size = 2) + 
  geom_smooth(method = "lm") +
  facet_grid(.~cyl)

ggplot(df, aes(hp, mpg)) + #  можно оставить на графике только само значение регрессионной прямой
  geom_smooth(method = "lm", se = F) + # уберем доверительные интервалы для регрессионной линии
  facet_grid(.~cyl)

#######################################################################################

#  очень важная тема при анализе регрессии - предсказание значений

fitted_values_mpg <- data.frame(mpg = df$mpg, fitted = fit$fitted.values)
#  создается data.frame с реальными и предсказанными значениями
#######################################################################################

# также можно предсказывать значения для новых переменных

new_hp <- data.frame(hp = c(100, 150, 129, 300))
# основываясь на новой переменной и на нашей модели, мы можем предсказать значения миль на галлон топлива 
# для новых значений лошадинных сил

predict(fit, new_hp)  # для этого есть функция предикт, которая на вход требует 2 аргумента:
# модель, и те данные, на которых мы будем предсказывать

new_hp$mpg <- predict(fit, new_hp)
#######################################################################################

# в предыдущих примерах в качестве предиктора, НП, выступала количественна переменная
# однако, регрессию можно применять и в том случае, когда в качестве предиктора выступает номинативная переменная

my_df <- mtcars

# число цилиндров логично рассматривать, как факторную переменную
#  однако, сначала выполним регрессию без перевода в факторную переменную:

fit <- lm(mpg ~ cyl, my_df)  # ЗП и НП количественные!
summary(fit)

ggplot(my_df, aes(cyl, mpg)) + 
  geom_point() +
  geom_smooth(method = "lm") +
  theme(axis.text = element_text(size = 25),
        axis.title = element_text(size = 25, face = "bold"))
# как оказалось, все точки существуют только на некоторых уровнях НП
# если переведем переменную в факторный вид:

my_df$cyl <- factor(my_df$cyl, labels = c("four", "six", "eight"))

fit <- lm(mpg ~ cyl, my_df)
summary(fit)  # теперь в качестве НП теперь выводится только 6 цилиндров и 8 цилиндров
# в качестве значения интерсепта принято среднее значение по 4 цилиндрам (по умолчанию выбирается один из уровней фактора)
# а коэффцииенты ниже показывают изменение среднего значения при переходе на 6 цилиндров и 8 цилиндров


aggregate(mpg ~ cyl, my_df, mean)  # рассчитаем среднее значение внутри групп

ggplot(my_df, aes(cyl, mpg)) + 
  geom_point() +
  theme(axis.text = element_text(size = 25),
        axis.title = element_text(size = 25, face = "bold"))
